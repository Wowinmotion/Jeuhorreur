Rituel dans les Bois — Jeu Browser :root{--bg:#0b0f12;--panel:#0f1720;--accent:#d94a4a;--muted:#9aa6b2} html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;background:linear-gradient(180deg,#031018,#06131a);color:#e6eef6} .wrap{max-width:980px;margin:18px auto;padding:16px} header{display:flex;gap:12px;align-items:center} h1{font-size:20px;margin:0} p.lead{margin:4px 0 12px;color:var(--muted)} .game-panel{display:flex;gap:14px} .canvas-wrap{background:linear-gradient(180deg,#08121a,#0a1a21);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(0,0,0,0.6)} canvas{display:block;background:transparent;border-radius:8px} .sidebar{width:300px;min-width:220px;background:var(--panel);padding:12px;border-radius:10px} .stat{display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px solid rgba(255,255,255,0.02)} .controls{margin-top:10px} button{background:#0b1220;border:1px solid rgba(255,255,255,0.04);color:#e6eef6;padding:8px 10px;border-radius:8px;cursor:pointer} button.action{background:var(--accent);border-color:rgba(0,0,0,0.2)} footer{margin-top:12px;color:var(--muted);font-size:13px} .log{height:150px;overflow:auto;background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;font-size:13px} @media (max-width:860px){.game-panel{flex-direction:column}.sidebar{width:100%}} 

Rituel dans les Bois — Version HTML jouable

Survis assez longtemps pour compléter le rituel : ramasse les 3 reliques et atteins la clairière. Évite la Lisière (l'entité). Mobile et desktop — utilise les flèches ou WASD. Toute l'expérience est contenue dans ce fichier.

<div class="game-panel"> <div class="canvas-wrap"> <canvas id="game" width="720" height="600" tabindex="0"></canvas> </div> <aside class="sidebar"> <div class="stat"><div>Etat</div><div id="state">Prêt</div></div> <div class="stat"><div>Points de vie</div><div id="hp">3</div></div> <div class="stat"><div>Reliques</div><div id="relics">0 / 3</div></div> <div class="stat"><div>Temps</div><div id="time">0s</div></div> <div style="margin-top:10px"><strong>Inventaire</strong> <div id="inv" style="margin-top:6px">Aucun</div> </div> <div class="controls"> <button id="start">Démarrer</button> <button id="restart">Recommencer</button> <button id="toggleSound">Son: ON</button> </div> <h4 style="margin-top:12px">Journal</h4> <div class="log" id="log"></div> <footer> Contrôles: Flèches / WASD. Touche E pour interagir. Version compacte — pas d'assets externes. </footer> </aside> </div> 

/* --- Jeu complet dans un seul fichier --- Règles: - Ramasser 3 reliques (R) puis aller à la clairière (goal) pour gagner. - Éviter l'entité (E) : collision -> perdre un coeur et télport aléatoire. - Déplacements 8 directions, IA ennemie suit le joueur par pathfinding simple (BFS on grid). - Items et obstacles générés aléatoirement, gameplay équilibré pour être jouable. */ const canvas = document.getElementById('game'); const ctx = canvas.getContext('2d'); const W = canvas.width, H = canvas.height; const gridSize = 24; // taille d'une cellule const cols = Math.floor(W / gridSize); const rows = Math.floor(H / gridSize); let game = null; function randInt(a,b){return Math.floor(Math.random()*(b-a+1))+a} class Game{ constructor(){ this.reset(); } reset(){ this.time = 0; this.ticks = 0; this.running=false; this.hp=3; this.relics=0; this.log=[]; this.player = {x: Math.floor(cols/2), y: Math.floor(rows/2)}; this.goal = {x: randInt(2,cols-3), y: randInt(2,rows-3)}; this.enemy = {x:1, y:1, wait:0}; this.tiles = [...Array(cols)].map(()=>Array(rows).fill(0)); // 0 empty, 1 wall for(let i=0;i<cols;i++){ for(let j=0;j<rows;j++){ if(Math.random()<0.06) this.tiles[i][j]=1; } } // guarantee start & goal free this.tiles[this.player.x][this.player.y]=0; this.tiles[this.goal.x][this.goal.y]=0; this.relicsPos = []; while(this.relicsPos.length<3){ let rx=randInt(1,cols-2), ry=randInt(1,rows-2); if(this.tiles[rx][ry]===0 && !(rx===this.player.x&&ry===this.player.y) && !(rx===this.goal.x&&ry===this.goal.y)){ this.relicsPos.push({x:rx,y:ry}); } } // fog of war radius this.visibility = 6; this.addLog('Jeu prêt. Ramasse les 3 reliques et retourne à la clairière.'); } addLog(t){ this.log.unshift('['+Math.floor(this.time)+'s] '+t); if(this.log.length>80) this.log.pop(); updateUI(); } start(){ if(this.running) return; this.running=true; this.startTS=Date.now(); this.addLog('Début du rituel'); } stop(){ this.running=false; } win(){ this.running=false; this.addLog('Tu as complété le rituel — Victoire !'); updateUI(); } lose(){ this.running=false; this.addLog('Tu es mort... Jeu terminé.'); updateUI(); } } function neighbors(x,y){ const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]; const out = []; for(const d of dirs){ const nx=x+d[0], ny=y+d[1]; if(nx>=0 && nx<cols && ny>=0 && ny<rows) out.push({x:nx,y:ny}); } return out; } // Simple BFS pathfinding returning next step toward target function nextStepBFS(sx,sy,tx,ty,tiles){ if(sx===tx && sy===ty) return {x:sx,y:sy}; const q=[]; const seen = Array.from({length:cols},()=>Array(rows).fill(false)); q.push({x:sx,y:sy,parent:null}); seen[sx][sy]=true; let found=null; let head=0; while(head<q.length){ const cur=q[head++]; if(cur.x===tx && cur.y===ty){ found=cur; break; } for(const n of neighbors(cur.x,cur.y)){ if(!seen[n.x][n.y] && tiles[n.x][n.y]===0){ seen[n.x][n.y]=true; q.push({x:n.x,y:n.y,parent:cur}); } } if(q.length>5000) break; // safe guard } if(!found) return null; // backtrack to first step let cur = found; while(cur.parent && cur.parent.x!==sx && cur.parent.y!==sy) cur = cur.parent; return {x:cur.x,y:cur.y}; } function draw(){ ctx.clearRect(0,0,W,H); // background grid for(let i=0;i<cols;i++){ for(let j=0;j<rows;j++){ const px=i*gridSize, py=j*gridSize; // dimmed by fog const d = Math.hypot(i-game.player.x, j-game.player.y); const visible = d<=game.visibility; if(game.tiles[i][j]===1){ ctx.fillStyle = visible? '#1b2a2a' : '#061013'; ctx.fillRect(px,py,gridSize-1,gridSize-1); } else { ctx.fillStyle = visible? '#0f2622' : '#031214'; ctx.fillRect(px,py,gridSize-1,gridSize-1); } } } // draw relics for(const r of game.relicsPos){ const d = Math.hypot(r.x-game.player.x, r.y-game.player.y); if(d<=game.visibility){ drawCircle(r.x,r.y, gridSize*0.35, '#ffd166'); drawText('R', r.x, r.y, '#2b1f00'); } } // draw goal if(Math.hypot(game.goal.x-game.player.x, game.goal.y-game.player.y)<=game.visibility){ drawCircle(game.goal.x, game.goal.y, gridSize*0.5, '#6ee7b7'); drawText('✵', game.goal.x, game.goal.y, '#043527'); } // draw enemy if(Math.hypot(game.enemy.x-game.player.x, game.enemy.y-game.player.y)<=game.visibility){ drawCircle(game.enemy.x, game.enemy.y, gridSize*0.44, '#ff6b6b'); drawText('E', game.enemy.x, game.enemy.y, '#200'); } // draw player drawCircle(game.player.x, game.player.y, gridSize*0.45, '#8ab4f8'); drawText('@', game.player.x, game.player.y, '#001133'); // UI overlays ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(6,6,220,44); ctx.fillStyle='#fff'; ctx.font='13px monospace'; ctx.fillText('Reliques: '+game.relics+' / 3',12,24); ctx.fillText('HP: '+game.hp,12,40); } function drawCircle(gx,gy,r,c){ ctx.beginPath(); ctx.fillStyle=c; ctx.arc(gx*gridSize+gridSize/2, gy*gridSize+gridSize/2, r, 0, Math.PI*2); ctx.fill(); } function drawText(t,gx,gy,color){ ctx.fillStyle=color; ctx.font='bold '+Math.floor(gridSize*0.6)+'px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(t, gx*gridSize+gridSize/2, gy*gridSize+gridSize/2); } // Game loop function tick(){ if(!game.running){ draw(); requestAnimationFrame(tick); return; } game.ticks++; const now = Date.now(); game.time = ((now - game.startTS)/1000); // enemy moves every N ticks if(game.ticks % 6 === 0){ const step = nextStepBFS(game.enemy.x,game.enemy.y,game.player.x,game.player.y, game.tiles); if(step){ game.enemy.x = step.x; game.enemy.y = step.y; } } // detect collision if(game.enemy.x===game.player.x && game.enemy.y===game.player.y){ game.hp -= 1; updateUI(); game.addLog('La Lisière t'a touché ! HP -1'); // teleport player to random free cell let tries=0; while(tries<200){ const tx=randInt(1,cols-2), ty=randInt(1,rows-2); if(game.tiles[tx][ty]===0){ game.player.x=tx; game.player.y=ty; break; } tries++; } if(game.hp<=0){ game.addLog('Plus de points de vie. Fin.'); game.lose(); } } // check relic pickup for(let i=game.relicsPos.length-1;i>=0;i--){ const r=game.relicsPos[i]; if(r.x===game.player.x && r.y===game.player.y){ game.relicsPos.splice(i,1); game.relics++; updateUI(); game.addLog('Tu as trouvé une relique !'); } } // check goal reach if(game.player.x===game.goal.x && game.player.y===game.goal.y){ if(game.relics>=3){ game.win(); } else { game.addLog('La clairière est active — mais il te manque des reliques.'); } } draw(); requestAnimationFrame(tick); } // Input const keys = {}; window.addEventListener('keydown', (e)=>{ if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].includes(e.key)) e.preventDefault(); keys[e.key]=true; if(e.key==='e' || e.key==='E') interact(); }); window.addEventListener('keyup', (e)=>{ keys[e.key]=false; }); function interact(){ // simple context action: pick up in same cell already auto-picked; allow 'sense' relics if(!game.running) return; game.addLog('Tu invoques un murmure...'); // reveal nearest relic for a short time if(game.relicsPos.length>0){ const r=game.relicsPos[0]; game.visibility = 9; setTimeout(()=>{ game.visibility=6; }, 3000); } } function playerStep(dx,dy){ if(!game.running) return; const nx=game.player.x+dx, ny=game.player.y+dy; if(nx<0||nx>=cols||ny<0||ny>=rows) return; if(game.tiles[nx][ny]===1) { game.addLog('Un obstacle bloque le passage.'); return; } game.player.x=nx; game.player.y=ny; updateUI(); } // handle continuous movement for smooth mobile tapping let moveCooldown=0; function handleMovement(){ moveCooldown--; if(moveCooldown>0) return; let dx=0, dy=0; if(keys['ArrowUp']||keys['w']||keys['W']) dy=-1; if(keys['ArrowDown']||keys['s']||keys['S']) dy=1; if(keys['ArrowLeft']||keys['a']||keys['A']) dx=-1; if(keys['ArrowRight']||keys['d']||keys['D']) dx=1; if(dx!==0||dy!==0){ playerStep(dx,dy); moveCooldown=6; } } setInterval(handleMovement,60); // UI functions function updateUI(){ document.getElementById('hp').innerText = game.hp; document.getElementById('relics').innerText = game.relics+' / 3'; document.getElementById('time').innerText = Math.floor(game.time)+'s'; document.getElementById('state').innerText = game.running? 'En cours' : 'En pause'; const inv = document.getElementById('inv'); inv.innerText = game.relics>0? (game.relics+' relique(s)'):'Aucun'; const logEl = document.getElementById('log'); logEl.innerText = game.log.slice(0,40).join('\n'); } // Buttons document.getElementById('start').addEventListener('click', ()=>{ if(!game.running){ game.start(); game.startTS=Date.now()-Math.floor(game.time*1000); } updateUI(); }); document.getElementById('restart').addEventListener('click', ()=>{ game.reset(); updateUI(); }); let soundOn = true; document.getElementById('toggleSound').addEventListener('click', ()=>{ soundOn=!soundOn; document.getElementById('toggleSound').innerText = 'Son: '+(soundOn?'ON':'OFF'); }); // click/touch to move (mobile) canvas.addEventListener('click', (ev)=>{ const rect = canvas.getBoundingClientRect(); const cx = ev.clientX-rect.left, cy = ev.clientY-rect.top; const gx = Math.floor(cx/gridSize), gy = Math.floor(cy/gridSize); const dx = Math.sign(gx - game.player.x); const dy = Math.sign(gy - game.player.y); playerStep(dx,dy); }); // game initialization function init(){ game = new Game(); updateUI(); draw(); gameLoop(); } function gameLoop(){ setInterval(()=>{ if(game && game.running) { /* tick already using rAF */ } },1000); requestAnimationFrame(tick); } // small helper: start on load init(); // expose to console for debugging window._game = ()=>game; 